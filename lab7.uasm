| Lugod, Waleed
| Sagusay, Joseph
| Warain, John Victor


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
| This sample .uasm program processes an array of ints (defined at the DATA
| portion of this file), multiplying each int by 2.
|
| Important note: All registers r0 to r31 are initially set to 0.
|
| Happy hacking! - eric

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

.include beta.uasm          | include the standard predefined macros

        LD(r31, DATA, r0)   | r0 = memory pointed to by DATA (the array length)
                            |  (r31 is a special register that is always zero,
                            |   and this line can be shortened to LD(DATA, r0))
LOOP:   ADDC(r1, 4, r1)     | r1 += 4 (that is, advance to the next int)
        LD(r1, DATA, r2)    | r2 = memory pointed to by (r1 + DATA)
        SHLC(r2, 1, r2)     | r2 = r2 << 1 (that is, multiply r2 by 2)
        ST(r2, DATA, r1)    | memory pointed to by (DATA + r1) = r2
        SUBC(r0, 1, r0)     | r0--
        BNE(r0, LOOP)       | if r0 != 0, go back to LOOP
        HALT()              | finish execution

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

| DATA marks the beginning of user data in memory.
DATA:   LONG(5)             | length of the array
        LONG(4)
        LONG(2)
        LONG(0)
        LONG(6)
        LONG(-9)


| 1. Sum of all even numbers in an array

.include beta.uasm

        LD(r31, DATA, r0)       | r0 = N
        ADDC(r31, 1, r1)        | r1 <--- counter
        ADDC(r31, 0, r5)        | r5 <--- sum

LOOP:   CMPLE(r1, r0, r2)
        BEQ(r2, DONE, r31)

        SHLC(r1, 2, r2)
        LD(r2, DATA, r2)        | r2 = arr[i]

        ANDC(r2, 1, r3)         | Check if last bit is 1 (i.e., check if odd)
        BNE(r3, SKIP_ADD, r31)  

        ADD(r5, r2, r5)
        ADDC(r1, 1, r1)
        BR(LOOP)

SKIP:   ADDC(r1, 1, r1)
        BR(LOOP)

DONE:
        MULC(r1, 4, r2)
        ST(r5, DATA, r2)
        HALT()

.=0x200
DATA:   LONG(5)
        LONG(3)
        LONG(-5)
        LONG(12)
        LONG(-14)
        LONG(1)
        LONG(0)


| 2. Reverse the elements of an array

.include beta.uasm

        ADDC(r31, DATA, r0)     | r0 <--- left pointer; r1 <--- right pointer
        LD(r31, DATA, r1)       | The left and right pointers are initially outside the array.
        SHLC(r1, 2, r1)         | The first iteration of the loop will place the
        ADD(r0, r1, r1)         | left and right pointers to the first and last elements respectively.
        ADDC(r1, 4, r1)      

LOOP:
        CMPLT(r0, r1, r3)       | Left and right pointers will converge to the middle element.
        BEQ(r3, END, r31)       | Once left pointer > right pointer, the loop ends.

        ADDC(r0, 4, r0)
        SUBC(r1, 4, r1)

        LD(r0, 0, r4)
        LD(r1, 0, r5)
        ST(r5, 0, r0)
        ST(r4, 0, r1)
        BR(LOOP)

END:
        HALT()

.=0x200
DATA:   LONG(5) 
        LONG(3)
        LONG(-5)
        LONG(12)
        LONG(-14)
        LONG(1)


| 3. XOR Cipher with a Repeating Key

.include beta.uasm

        LD(r31, DATA, r0)       | r0 <--- Key
        ADDC(r31, 4, r1)        
        LD(r1, DATA, r1)        | r1 <--- Plain text's length
        ADDC(r31, 1, r2)        | r2 <--- Counter


LOOP:   CMPLE(r2, r1, r3)
        BEQ(r3, DONE, r31)

        SHLC(r2, 2, r3)         | Compute for offset 
        ADDC(r3, 4, r3)         | r3 <--- offset
        LD(r3, DATA, r4)
        XOR(r0, r4, r4)         | r4 <--- encrypted plain text
        ST(r4, DATA, r3)

        ADDC(r2, 1, r2)
        BR (LOOP)

DONE:   HALT()

.=0x200
DATA:   LONG(42)
        LONG(5)
        LONG(3)
        LONG(-5)
        LONG(12)
        LONG(-14)
        LONG(1)



| 4. Fibonnaci
.include beta.uasm

        LD(r31, DATA, r0)               | r0 <--- next
        ADDC(r31, 1, r1)                | r1 <--- counter

LOOP:   CMPLE(r1, r0, r2)
        BEQ(r2, end, r31)

        CMPEQC(r1, 1, r2)               | On the first two iterations of the LOOP,
        BNE(r2, APPEND_ZERO, r31)       | the program writes 0 then 1.
        CMPEQC(r1, 2, r2)
        BNE(r2, APPEND_ONE, r31)

        SUBC(r1, 2, r2)                 | Get the last two elements
        SUBC(r1, 1, r3)                 | Then add them
        MULC(r2, 4, r2)                 | Sum is in r2
        MULC(r3, 4, r3)
        LD(r2, DATA, r2)
        LD(r3, DATA, r3)
        ADD(r2, r3, r2)

        MULC(r1, 4, r3)        
        ST(r2, DATA, r3)
        ADDC(r1, 1, r1)
        BR(LOOP)

APPEND_ZERO: MULC(r1, 4, r2)            | r2 <--- offset
        ADD(r31, r31, r3)               | Load 0 into r3
        ST(r3, DATA, r2)
        ADDC(r1, 1, r1)
        BR(while_loop)

APPEND_ONE: MULC(r1, 4, r2)             | r2 <--- offset
        ADDC(r31, 1, r3)                | Load 0 into r3
        ST(r3, DATA, r2)
        ADDC(r1, 1, r1)
        BR(while_loop)

end:
        HALT()

.=0x200
DATA: LONG(10)
